## 데이터 중심 설계

객체가 가져야 할 `상태(데이터)`를 먼저 결정하고, 그 데이터를 조작하는 로직을 나중에 고민하는 방식

### 특징

* 객체들이 단순히 **데이터 보관소** 역할
* `Movie`, `Screening` 등은 필드와 `getter`, `setter`만 존재
* `ReservationAgency`에서 모든 데이터를 가져와 **절차지향적으로 로직 처리**

### 문제점

**1. 캡슐화 위반**
* `Movie`의 할인 정책 변경 → `ReservationAgency` 코드도 함께 수정

**2. 높은 결합도**
* 여러 객체의 데이터에 의존
* 한 객체의 변경이 다른 객체에 영향

**3. 낮은 응집도**
* `ReservationAgency`가 과도하게 많은 이유로 변경됨
* 할인 정책 변경, 할인 조건 변경 등 모든 변경사항이 한 곳에 집중

## 책임 중심 설계

객체가 수행해야 할 **행동(책임)**을 먼저 결정하고, 그 행동을 수행하는 데 필요한 데이터를 나중에 결정하는 방식

### 특징

* 객체가 **스스로 자신의 데이터를 제어**
* 로직이 여러 객체로 분산됨
* 객체들은 서로 **메시지를 주고받으며 협력**

## 왜 책임 중심 설계가 더 좋을까?

책임 중심 설계가 더 좋은 이유는 **변경에 유연**하기 때문이다.

### 자율적인 객체

* 객체가 자신의 상태를 직접 관리
* 내부 구현이 변경되더라도 외부 객체는 알 필요가 없음

### 캡슐화

캡슐화는 단순히 `private` 변수를 만드는 것이 아님

**변할 수 있는 모든 것을 감추는 것**이 캡슐화

> `private`으로 선언했더라도 `getter`, `setter`를 통해 외부에서 자유롭게 접근 가능하다면 사실상 `public`과 크게 다르지 않다.

### 낮은 결합도

* 객체 간 의존성이 줄어듦
* 메시지를 통한 협력으로 연결
* 시스템의 한 부분을 수정해도 다른 부분에 미치는 영향이 적음

## 핵심 정리

데이터 중심 설계 → 책임 중심 설계로 리팩토링 과정을 통해 **캡슐화, 응집도, 결합도**의 중요성을 이해

**데이터를 묻지 말고 책임을 할당하라**

객체에게 데이터를 **묻는 것**이 아니라, 스스로의 상태를 기반으로 판단하고 행동하도록 **책임을 할당**

변경에 유연하게 대응할 수 있는 자율적인 객체들의 **협력 구조** 설계