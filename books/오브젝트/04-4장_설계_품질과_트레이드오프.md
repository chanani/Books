# 4장. 설계 품질과 트레이드오프

## 데이터 중심 설계

첫 번째 예제는 객체가 가져야 할 **상태(데이터)** 를 먼저 결정하고, 그 데이터를 조작하는 로직을 나중에 고민하는 방식이다.

### 특징

- 객체들이 단순히 **데이터 보관소** 역할을 수행
- `Movie`, `Screening` 등은 필드와 `getter`, `setter`만 존재
- `ReservationAgency`에서 모든 데이터를 가져와 **절차지향적으로 로직 처리**

### 문제점

1. **캡슐화 위반**
    - `Movie`의 할인 정책이 변경되면 `ReservationAgency` 코드도 함께 수정해야 함

2. **낮은 응집도**
    - `ReservationAgency`가 과도하게 많은 이유로 변경됨 (할인 정책 변경, 할인 조건 변경 등)

---

## 책임 중심 설계

두 번째 예제는 객체가 수행해야 할 **행동(책임)** 을 먼저 결정하고, 그 행동을 수행하는 데 필요한 데이터를 나중에 결정하는 방식이다.

### 특징

- 객체가 **스스로 자신의 데이터를 제어**
- 로직이 여러 객체로 분산됨
- 객체들은 서로 **메시지를 주고받으며 협력**

---

## 왜 책임 중심 설계가 더 좋을까?

책임 중심 설계가 더 좋은 이유는 **변경에 유연**하기 때문이다.

### 자율적인 객체

- 객체가 자신의 상태를 직접 관리
- 내부 구현이 변경되더라도 외부 객체는 알 필요가 없음

### 캡슐화

- 캡슐화는 단순히 `private` 변수를 만드는 것이 아님 **변할 수 있는 모든 것을 감추는 것**이 캡슐화

> `private`으로 선언했더라도 `getter`, `setter`를 통해 외부에서 자유롭게 접근 가능하다면 사실상 `public`과 크게 다르지 않다.

### 낮은 결합도

- 객체 간 의존성이 줄어듦
- 메시지를 통한 협력으로 연결되기 때문에 시스템의 한 부분을 수정해도 다른 부분에 미치는 영향이 적음

---

## 개인적인 Chapter 4 요약

데이터 중심 설계로 구성된 프로젝트를 책임 중심 설계로 리팩토링하는 과정을 통해 **캡슐화, 응집도, 결합도**의 중요성을 명확하게 이해할 수 있었다.

객체에게 데이터를 **묻는 것**이 아니라, 스스로의 상태를 기반으로 판단하고 행동하도록 **책임을 할당**해야 한다.

이를 통해 변경에 유연하게 대응할 수 있는 자율적인 객체들의 **협력 구조**를 설계해야 한다는 점을 깨달았다.
