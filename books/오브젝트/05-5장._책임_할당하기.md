## 01. 책임 주도 설계를 향해

### 데이터보다 행동을 먼저 결정하라

객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동이다.
`데이터`는 객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐이다.

> 데이터 중심 설계 : `이 객체가 표함해야 하는 데이터가 무엇인가` > `데이터를 처리하는 데 필요한 오퍼레이션은 무엇인가`  
> 책임 주도 설계 : `이 객체가 수행해야 하는 책임은 무엇인가` > `이 책임을 수행하는 데 필요한 데이터는 무엇인가`

### 협력이라는 문맥 안에서 책임을 결정하라

책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.
메시지를 전송하는 `클라이언트의 의도에 적합한 책임`을 할당해야 한다.
객체가 메시지를 선택하는 것이 아니라 `메시지가 객체를 선택`하게 해야 한다.

### 책임 주도 설계

책임 주도 설계의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것이다.
협력에 참여하는 객체들의 책임이 어느 정도 정리될 때까지는 객체의 내부 상태에 대해 관심을 가지지 않는 것이다.

## 02. 책임 할당을 위한 GRASP 패턴

> GRASP 패턴 : 객체에게 책임을 할당할 떄 지침으로 삼을 수 있는 원칙들의 집합

### 도메인 개념에서 출발하기

어떤 책임을 할당해야 할 떄 먼저 고민해야 하는 유력한 후보는 바로 도메인 개념이다.
설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려보는 것이 유용하다.

### 정보 전문가에게 책임을 할당하라

책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것  
GRASP에서는 이를 `INFORMATION EXPERT(정보 전문가)` 패턴이라고 부른다.

### 높은 응집도와 낮은 결합도

객체에 책임을 할당할 때 항상 고려해야 하는 기본 원리다.
책임을 할당할 수 있는 다양한 대안들이 존재한다면 `응집도와 결합도`의 측면에서 더 나은 대안을 선택하는 것이 좋다.  
다시 말해 두 협력 패턴 중에서 `높은 응집도와 낮은 결합도`를 얻을 수 있는 설계가 있다면 그 설계를 선택해야 한다는 것이다.

GRASP에서는 이를 `LOW COUPLING(낮은 결합도)`과 `HIGH COHESION(높은 응집도)` 패턴이라고 부른다.

### 창조자에게 객체 생성 책임을 할당하라

`GRASP에서는 CREATOR(창조자)` 패턴은 객체를 생설할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.

## 03. 구현을 통한 검증

응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있다는 것을 의미한다.  
따라서 낮은 응집도가 초래하는 문제를 해결하기 위해서는 `변경의 이유에 따라 클래스를 분리해야 한다.`

코드를 통해 변경의 이유를 파악할 수 있는 방법

1. 인스턴스 변수가 초기화되는 시점을 살펴보는 것
    - 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보는 것
    - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라는 것이다.
GRASP에서는 이를 `PLYMORPHISM(다형성)` 패턴이라고 부른다.

변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서는 `PROTECTED VARIATIONS(변경 보호)` 패턴이라고 부른다.

## 04. 책임 주도 설계의 대안

> 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을 리팩터링이라고 부른다.

### 메서드 응집도

긴 메서드는 다양한 측면에서 코드의 유지보수에 부정적인 영향을 미치게 된다.

- 어떤 일을 수행하는지 한눈에 파악하기 어렵기에, 코드를 전체적으로 이해하는데 너무 많은 시간이 걸린다.
- 하나의 메서드 안에서 너무 많은 직업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.
- 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.
- 로직의 일부만 재사용하는 것이 불가능하다.
- 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여 넣는 것뿐이므로 코드 중복을 초래하기 쉽다.

긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어렵다.
이를 `몬스터 메서드`라고 부른다.



